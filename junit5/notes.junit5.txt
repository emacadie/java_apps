https://junit.org/junit5/docs/current/user-guide/
https://junit.org/junit5/docs/5.6.2/user-guide/
https://junit.org/junit5/
API: https://junit.org/junit5/docs/current/api/
https://junit.org/junit5/docs/5.6.0/api/
https://junit.org/junit5/docs/5.6.2/api/

Tests should be easy to understand, easy to read and easy to modify
I guess that eliminates mocking and stubbing

Types of test:
black box, white box: Determined by knowledge of internals of system
This course focuses on unit test

Tests should be automated, repeatable, fast
To test databases: http://dbunit.sourceforge.net/
Integration tests: Test how components work together (like web services, databases)

Why are tests important?
reduce debugging time
serve as documentation (but what calls the code you're testing?)
help to improve design

JUnit 5 has three modules:
JUnit Platform
JUnit Jupiter
JUnit Vintage

JUnit5 architecture:
one jar, not very flexible, tightly coupled
lots of tools did reflection and looked at private variables
now we have separation of concerns
1. API to write tests
2. Mechanism to discover and run tests
3. API to run tests (for tools)
decouple execution and definition
preference for extension points

JUnit Platform - API to launch tests (console, IDE, others) and to develop testing framework
JUnit Jupiter - for writing tests and extensions, and platform to run Jupiter tests on platform
JUnit Vintage (runs JUnit 3 & 4 tests)

Test method phases:
1. set up objects you need for test
2. perform an action
3. check if result was what you expect

or phrase it this way:
1. arrange
2. act
3. assert
4. annihilation (put system back in state you found it) usually automatic for Java (garbage collection)

lifecycle:
Test fixture: creating objects for test
transient fresh
persistence fresh
persistence shared
annotations:
In org.junit.jupiter.api I think
@AfterEach @BeforeEach: once per method
@AfterAll @BeforeAll: once per class

by default: JUnit creates new instance of each test class before each test (seems inefficient, even if it is clean)
seems inefficient
You can change this to per class:
@org.junit.jupiter.api.TestInstance(TestInstance.Lifecycle.PER_METHOD)
@org.junit.jupiter.api.TestInstance(TestInstance.Lifecycle.PER_CLASS)
You can also do this with JVM property -Djunit.jupiter.testinstance.lifecycle.default=per_method (or per_class)
Can also be set in junit-platform.properties in root of classpath

convention is to make a null variable to hold class
and put constructor call in @BeforeEach setUp

Maybe I am not the sharpest knife in the drawer, but I am not sure I see the point of @Nested classes and tests
Why not just create the inputs in the test method? It would be fewer lines of code.

combining @Nested with @DisplayName you could make "given", "when", "then" lines like Cucumber
given: @BeforeEach setUp
then: @Test
or:
given: @Nested class
given: @Nested class inside that one
when: @BeforeEach setUp in nested nested class
then: @Test
or:
given: @Nested
when and then: @Test
used in BDD - application is specified and designed by describing how it should behave
Test phase to BDD:
arrange -> given
act -> when
assert -> then

nested test classes:
use non-static inner classes - @BeforeAll and @AfterAll won't work by default (only w/Lifecycle.PER_CLASS, which can override)
use w/@DisplayName

assertions:
good test should have one act and one assert operation
also said you can have one act and multiple assertions
but not multiple actions

assertAll
assertArrayEquals
assertEquals
assertFalse
assertIterableEquals
assertLinesMatch
assertNotEquals
assertNotNull
assertNotSame
assertNull
assertSame
assertThrows
assertTimeout
assertTimeoutPreemptively
assertTrue
fail

External Assertion Libraries:
AssertJ
Hamcrest

assertions: usually first arg is expected, second is what you got,
optional third is an error message if something is wront
() -> {
    System.out.println( "Lazy loaded" );
    return "Error, the product ID is incorrect"; // this goes in stack trace
}

Multiple assertions? Use Assertions.assertAll and lambdas
If one fails, others will still be executed

to disable tests:
use annotation  org.junit.jupiter.api.Disabled on methods or classes
Like Spock's Ignore
There is also
DisabledIf
DisabledIfEnvironmentVariable
DisabledIfSystemProperty
Unlike commenting out @Test, @Disabled forces you to give a reason

org.junit.jupiter.api.Assumptions
Failed Assumptions do not result in a test failure, only failed assertions

You can put assumptions in setUp to control if a test should be run

They like the org.junit.jupiter.api.function.Executable interface
use it to create lambdas as an arg

Other annotations:
@ExtendWith
@ParameterizedTest
@RepeatedTest
@Tag
@TestFactory
@TestTemplate

For interfaces, methods w/@BeforeAll and @AfterAll must be static
use @TestInstance(Lifecycle.PER_CLASS)

How to repeat a test?
@RepeatedTest
You can give a custom name to each test
If you use @RepeatedTest, you do not need @Test

We can create tests at runtime
DynamicTests (like generative tests?), Parameterized Test
Use method annotated with @TestFactory to create dynamic tests
method cannot be private or static
as your source, use Collection, something that implements Iterable, Iterator, or Stream
DynamicContainer contains dynamic tests, or other DynamicContainer instances
From API for DynamicContainer: It is composed of a display name and an Iterable or Stream of DynamicNodes.

DynamicTest: has a display name and Executable (functional interface)
@BeforeEach and @AfterEach are not executed for dynamic tests

If one dynamic test fails, others will still run
@BeforeEach will only get executed once



