

Java 8 api: https://docs.oracle.com/javase/8/docs/api/

gradle compileJava
gradle build

gradle runJava -PmainClass=info.shelfunit.morelambda.FirstRunner -PmainArgs="doStuffInlineAndLambda"
gradle runJava -PmainClass=info.shelfunit.morelambda.FirstRunner -PmainArgs="comparePerson"
gradle runJava -PmainClass=info.shelfunit.morelambda.DataProcessor -PmainArgs="workWithPredicates"
gradle runJava -PmainClass=info.shelfunit.morelambda.DataProcessor -PmainArgs="workWithFunctionalInterfaces"

gradle runJava -PmainClass=info.shelfunit.funcjava.ch02.ChapterTwoRunner -PmainArgs="pickName N"

Comparator: object that can compare two objects
Only one method: int compare, can be done inline
Can pass as an arg to Arrays.compare
Runnable can be passed to E
Anonymous classes
Passed code as a parameter

Lambda: you cannot specify the return value
You can omit the types of the parameters
But I think it is better to keep them
If one line, no need for a return statement
Lambda: new way of making anonymous classes: sending code to a method

Lambda expression: instance of functional interface
functional interface: interface w/only one method
only one abstract method
default methods do not count
static methods do not count
methods from Object class do not count

You could put @FunctionalInterface annotation on them if you want
(it's in java.lang)
But it is optional
From API page: "Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references. "
Maybe I will just stick with lambda expressions.
Lambda expressions essentially implement functional interfaces.
Although some lambda expressions are on methods that are not functional interfaces (like Streams)

java.util.function package
4 basic categories
1. Consumers - consumes an object, does not return anything (usually have "accept" method and "andThen" method)
BiConsumers take two objects instead of one
BiConsumer,  Consumer, DoubleConsumer, IntConsumer, LongConsumer, ObjDoubleConsumer, ObjIntConsumer, ObjLongConsumer
2. Suppliers - supplier provides an object, takes no parameter (sort of like a Factory w/out args?)
why not just call a constructor?
https://www.geeksforgeeks.org/supplier-interface-in-java-with-examples/ gives example w/Random
But it still seems that you could just call the underlying method
Method: get() for Supplier, getAs$Type() for others
BooleanSupplier, DoubleSupplier, IntSupplier, LongSupplier, Supplier
3. Functions
Function takes an object, returns object of another type (so it's like mapping)
Methods in java.util.function.Function:
andThen, apply, compose, identity
Most of them just have apply or applyAs$Type
BiFunction, DoubleFunction, DoubleToIntFunction, DoubleToLongFunction, Function, IntFunction, IntToDoubleFunction,
IntToLongFunction, LongFunction, LongToDoubleFunction, LongToIntFunction, ToDoubleBiFunction, ToDoubleFunction,
ToIntBiFunction, ToIntFunction, ToLongBiFunction, ToLongFunction
I also think the interfaces ending in "Operator" fall under this category (extend Function, BiFunction):
BinaryOperator, DoubleBinaryOperator, DoublePredicate, DoubleUnaryOperator, IntBinaryOperator, IntUnaryOperator,
LongBinaryOperator, LongUnaryOperator, UnaryOperator
4. Predicates - takes an object, returns a boolean (for filter)
Methods: test, and, or, negate
BiPredicate, IntPredicate, LongPredicate, Predicate

Functional interfaces for primitive types: IntPredicate, IntFunction, etc, etc


